# 数据结构

## 绪论

抽象数据类型描述了数据的逻辑结构和抽象运算=》用（数据对象，数据关系，基本操作集）这样的三元组来表示
逻辑结构是数据元素之间的逻辑关系，与数据的存储无关，分为线性结构和非线性结构
逻辑结构可以独立于存储结构，但是存储结构是逻辑结构的映射
![alt text](逻辑结构.png)
数据的存储结构包括 链式存储，顺序存储，索引存储，散列存储

### 算法的基本概念

算法一般具有五个重要特征=》有穷性，确定性，可行性，输入，输出
好的算法应该有以下四个指标=》健壮性，正确性，可读性，高效率和低存储需求

---
我们通常使用时间复杂度和空间复杂度来衡量一个算法的性能
时间复杂度是指基本运算的频度：是执行时间的度量
空间复杂度指的是辅助空间的大小（处理程序和输入外的额外空间）

## 线性表

## 栈，队列和数组

### 栈

栈是一种先进后出的数据结构
卡特兰数公式：当个不同元素入栈时,出栈元素不同排列的个数为
$$
\frac{1}{n+1} C_{2n}^{n}
$$
栈的基本操作包含入栈，出栈，判断栈是否为空等等

#### 共享栈

使两个栈共享一个一维数组空间，栈底分别设置为栈的两端，向中间延伸

#### 链栈

我们使用单链表来表示栈，这使得栈没有大小限制，同时规定入栈和出栈均在链表的头结点

### 队列

队列是一种先进先出的数据结构
为了避免假溢出情况，我们通常将队列臆造为环形结构
此时为了区分队满和队空，一般存在如下三种方法

1. 牺牲一个存储单元来区分队空和队满，约定以队尾指针指向队首指针下一个位置来表示队慢
队满条件: (Q.rear+1) %MaxSize  == Q.front。
队空条件: Q.front==Q.rear。

2. 类型中添加size成员变量，用来标识当前队列中成员个数

3. 增加tag成员变量来标识最后一次的操作，如果最后一次操作时插入tag = 1，如果时删除tag = 0。

##### 链式队列

链式队列包含两个指针，分别指向队头结点和队尾结点

##### 双端队列

指的时可以在队头和队尾进行插入和删除的队列，就是C++STL中的deque

### 栈和队列的应用

##### 栈

- 括号匹配
- 算数表达式求值
- 递归

中缀表达式转后缀表达式

1) 遇到操作数。直接加入后缀表达式。
2) 遇到界限符。若为“(”,则直接入栈;若为“)”,则不入栈,且依次弹出栈中的运算
符并加入后缀表达式,直到遇到“(”为止,并直接删除“(”。
3) 遇到运算符。①若其优先级高于栈顶运算符或遇到栈顶为“(”,则直接入栈;②若其优先级低于或等于栈顶运算符,则依次弹出栈中的运算符并加入后缀表达式,直到遇到一个优先级低于它的运算符或遇到“(”或栈空为止,之后将当前运算符入栈。
按上述方法扫描所有字符后,将栈中剩余运算符依次弹出,并加入后缀表达式。

后缀表达式求值
从左往右依次扫描表达式的每一项,若该项是操作数,则将其压入栈中;若该项是操作符<op>,则从栈中退出两个操作数和x,形成运算指令X<op>Y,并将计算结果压入栈中。当所有项都扫描并处理完后,栈顶存放的就是最后的计算结果。

##### 队列

- 层次遍历
- 操作系统中的就绪队列，阻塞队列等等

### 矩阵

矩阵其实就是对顺序表的扩展，增加了其维数
这里介绍几种特殊的矩阵的压缩存储方法

1. 对称矩阵：存储上三角或者下三角
2. 三角矩阵: 只按行或者按列用一维数组存储
3. 稀疏矩阵；三维存储，直接存储矩阵中的元素数量和每个元素行 列 值。

## 串

这里最重要的就是模式匹配了，KMP算法和优化的KMP算法时重中之重

##### 基础概念

前缀：除了最后一个字符外，字符串所有的头部子串
后缀：除了第一个字符外，字符串的所谓尾部
部分匹配值：字符串前缀和后缀最长相等前后缀长度
next数组：当模式串的第j个指针失配的时候，跳到next[j]的位置继续

##### KMP算法

暴力求解中每次匹配失败就要从头开始匹配
而我们如果从分析模式串本身的结构入手
若已经匹配相等的前缀序列中某个后缀正好是模式串的前缀，那么就可将模式串向右移动到与这些相等对齐的位置，这就是计算next数组的依据，使用了KMP算法，主串就无需回溯

---
next数组手算方法
在不匹配的位置前画一条分界线,模式串一步一步往后退,直到分界线之前能对上(首尾重合),或模式串完全跨过分界线为止。

---
求next数组公式
![Alt text](求next.png)

```C++
next数组的代码求法
void get_next(SString T, int next []) {
  int i=1,j=0;
  next [1]=0;
  while(i<T.length) {
    if (j==0||T.ch[i]==T.ch[j]) {
        ++i; ++j;
        next[i]=j; //若p=p,则 next[j+1]=next [j] +1
        }
    else
      j=next[j]; //否则令j=next[j],循环继续
  }
}
```

## 树

### 基本概念

#### 树的定义

树是n个结点的有限集合
任意一颗非空树应该满足

1. 有且只有一个根节点
2. 当n>1的时候，其余结点可分为m个互不相交的有限集，每个集合本身又是一颗树，并称为根的子树

##### 基本术语

结点层次：从树根开始定义，根结点为第一层 。。。
结点深度：结点所在的层次
树的高度：结点的最大层数
结点的高度：以该结点为根的子树的高度

结点的度：一个结点的孩子数量
树的度：结点的最大度数

分支结点：度大于0的结点
叶子结点：度等于0的结点

路径和路径长度
树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的,而路径长度是路径上所经过的边的个数。

##### 树的性质

1. 树的结点树n = 所有结点度数和+1
2. 度为m的树中第i层最多m^(i-1)个结点
3. 高度为h的m叉树至多存在（m^h-1）/（m-1）个结点


#### 二叉树的概念

##### 二叉树的定义

每个结点至多存在两棵子树的树

几种特殊的二叉树

1. 满二叉树
每层都含有最多的结点
2. 完全二叉树
当且仅当每隔结点都与高度为h的满二叉树中编号1~n的结点一一对应，称为完全二叉树
3. 二叉排序树
左子树所有结点的关键字均小于根节点的关键字，右子树所有结点关键字都大于根节点
4. 平衡二叉树
树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。
5. 正则二叉树
树中只有度为0或者2的结点

##### 二叉树的性质

1. 非空二叉树上叶子结点数 = 度为2的结点数+1
2. 空指针数量 = 结点数n+1

#### 二叉树的存储结构

##### 顺序存储结构

二叉树的顺序存储是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素,即将完全二叉树上编号为i的结点元素存储在一维数组下标为i-1的分量中。

##### 链式存储结构

```C++
struct TreeNode{
  int val;
  TreeNode * rchild;
  TreeNode * lchild;
  TreeNode(int x):val(x),rchild(nullptr),lchild(nullptr){}
  TreeNode():val(0),rchild(nullptr),lchild(nullptr){}

}
```

##### 二叉树的遍历

二叉树的遍历一般情况下有四种
先序，中序，后序，层次
前三种序列遍历的递归算法非常简单，只需要将处理函数换一个顺序即可
```C++
void PreOrder(TreeNode *T){
  if(T!=nullptr){
    visit(T);
    PreOrder(T->lchild);
    PreOrder(T->rchild);
  }
}
```

对于层次遍历，我们就需要使用一个队列了

```C++
void LevekOrder(TreeNode * T){
  queue<int> Q;
  Q.push(T);
  while(!Q.empty()){
    TreeNode *temp = Q.front();
    Q.pop();
    visit(temp);
    if(temp->lchild!=nullptr) Q.push(temp->lchild);
    if(temp->rchild!=nullptr) Q.push(temp->rchild);
  }
}
```

##### 线索二叉树

传统的二叉树只能体现父子关系，不能得到结点在遍历中的前驱或者后继
每棵树的空指针数量为结点数+1，我们利用这n+1个空指针，使得若无左子树,令lchild 指向其前驱结点:若无右子树,令rchild 指向其后继结点。增加两个标志域,以标识指针域指向左(右)孩子或前驱(后继)。

##### 中序线索二叉树


生成树 =》 就是极小联通子图 =》无环且联通
联通分量 =》 极大联通子图：一个图如果是联通的，那么只存在一个联通分量，如果不连通，存在多个
极小联通子图 =》最小网络

#### 折半查找判定树

折半查找是针对顺序存储的有序序列，因此折半查找排序树必是一颗二叉排序树

- 中序遍历可以得到一个有序序列
- mid向上取整 =》右子树结点数 = 左子树结点数 || 左-1 = 右
- mid向下取整 =》左子树结点数 = 右子树结点数 || 右-1 = 左

#### 哈夫曼树

最优二叉树=》树的带权路径长度达到最小，用于构造哈夫曼编码
note：请按照左小右大，左0右1的顺序构造

### 排序

基数排序
基数排序的思想是按照基数位进行多趟的入队出队操作

稳定的四种排序算法 =》基，冒，插，归

不稳定的四种排序算法 =》选，堆，希，快
