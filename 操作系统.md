# 操作系统
## 进程和线程
我们使用进程控制块来描述进程的基本情况和允许状态
进程实体（也称为进程映像）包括：程序段，数据段，PCB

##### 进程的特性
- 动态性=》进程时程序的一次执行
- 并发性=》多个进程同存于内存
- 独立性=》进程时独立允许，独立获取资源的基本单位
- 异步性=》进程各自独立，不可预知的速度向前推进

##### 进程组成
- PCB=》进程创建的时候，操作系统为其创建一个PCB，此后该结构常驻内存，并在进程结束后删除
![alt text](PCB内容.png)
1. 进程描述信息：进程标识符：标识进程、用户标识符：标识所属用户
2. 进程控制和管理信息：描述进程当前状态，标识优先级
3. 资源分配清单：说明有关内存地址空间或者虚拟空间的情况
4. 处理及相关信息：也称CPU上下文，主要指的是CPU内部各个寄存器的值

note：我们通常采用链接方式或者索引方式来管理PCB
 - 链接方式：根据阻塞原因不同，排成多个阻塞队列
 - 索引方式：将同一个状态的进程组织在一个索引表中，不同表项执行对应的PCB

- 程序段：CPU执行的程序代码段
- 数据段：一个进程的数据段

##### 进程状态与切换
运行态，就绪态，阻塞态，创建态，终止态
- 这里说一下什么为创建态，这里你要清楚进程创建的步骤，在进程创建的时候，需要先申请PCB，然后向其中填写控制信息，随后分配资源，如果资源不足，就会等待资源，此时处于创建态，当得到资源的时候，初始化PCB，随后插入就绪队列
![alt text](pro状态切换.png)
需要注意的是：进程从阻塞态变为就绪态是被动的行为，需要其它进程协助，但是就绪=》阻塞是主动的行为

##### 进程控制
一般称进程控制用的程序段为原语，原语的特点是执行期间不允许中断

- 运行一个进程创建另一个进程，此时创建者称为父进程，被创建者为子进程，子进程可以继承父进程所拥有的资源

进程终止
- 根据其标识符，检索对于PCB，然后读出该进程状态
- 如果处于运行态，立即终止该进程，然后将其CPU资源分配给其它进程
- 如果该进程还有子孙进程，一般需要将子孙进程终止
- 将该进程所拥有的全部资源归还父进程或者操作系统
- 删除其PCB

##### 进程阻塞与唤醒
- 进程使用阻塞原语（BLOCK）来使自己由运行态变为阻塞态（可见阻塞时一种主动行为）
- 当阻塞进程所期待的时间发生的时候，由有关进程调用唤醒原语（WAKEUP），将等待该事件的进程唤醒（被动行为）

##### 进程间的通信
匿名管道：最简单的IPC形式，在​​具有亲缘关系（通常是父子或兄弟）​​ 的进程间创建单工（半双工）字节流通道。数据写入管道的写入端，从读取端顺序读取（FIFO）。

命名管道：突破管道必须具有亲缘关系的限制，允许​​任何进程（甚至无亲缘关系）​​ 通过打开这个“文件”名进行通信。遵循FIFO原则。

消息队列：在内核中维护的​​消息链表​​。进程可以向队列添加​​结构化的消息​​（有类型和负载数据）或从队列中读取特定类型的消息。消息具有优先级（POSIX）或类型（SysV），使用发送消息和接收消息两个原语进行数据交换，目前的应用最广泛，微内核和服务器之间使用该通信方式。
- 直接通信方式=》直接将消息发送给对于进程，挂载到其消息队列上
- 间接通信方式：一般发送到某个中间实体，接收方从中间实体获得信息，中间实体一般称为信箱

共享内存：​​速度最快的IPC方式​​！内核将同一块物理内存映射到多个进程各自的用户空间地址范围。进程可以直接读写这块内存，就像访问自己的内存一样，​​无需内核介入拷贝​​。

信号量：它是一个用于​​同步多个进程​​（或线程）对​​共享资源​​（如共享内存区域、文件、硬件设备）访问的计数器。基本操作是PV操作（wait/P - 申请资源减小计数，signal/V - 释放资源增加计数）。

信号：用于通知进程发生了某个事件的机制，每类信号定义了一个序号，在进程的PCB 中,用至少n位向量记录该进程的待处理信号，若给某个进程发送一个信号,则把该类信号对应的位修改为1。一旦该信号被处理,就把对应的位修改为0。

socket：最强大、最通用的IPC/RPC机制​​。支持不同主机（网络IPC）或同一主机（Unix Domain Socket）上进程间通信。

##### 线程的引入
线程可以理解为更轻量级别的进程，为处理机调度的基本单位，其基本不拥有自己的资源（除了线程id,以及其自己的线程控制块（包含线程id以及寄存器，堆栈指针等等））

##### 线程和进程的区别
这个作为面试中的重要考点：请牢记
- 进程是系统中拥有资源的基本单位,而线程基本不拥有系统资源，属于同一进程的所有线程都具有相同的地址空间。
- 每个进程都不允许其余进程访问自己的独立地址空间和资源（除了全局变量），同一个进程中的线程间共享资源
- 在创建或撤销进程时,系统都要为之分配或回收进程控制块(PCB)及其他资源,如内存空间、I/O设备等，明显大于创建线程时的开销
- 进程切换需要保存进程上下文，而线程切换只需要保存和设置少量寄存器的值
- 线程支持多处理机系统，但是进程只能在单CPU上运行

##### 线程的实现方式
1. 用户级线程
线程的管理都在用户空间由用户程序进行，此时的线程对于操作系统透明
![Alt text](用户级线程.png)
2. 内核级线程
操作系统为每个内核级线程设置一个线程控制块 TCB,内核根据该控制块感知某线程的存在,并对其加以控制。
![Alt text](内核级线程.png)
3. 混合级线程
内核级线程对应多个用户级线程,这是用户级线程通过时分多路复用内核级线程实现的。
![Alt text](混合.png)

### 协程
##### 什么是协程
协程是一种更轻量级别的线程，可以在某个位置停止执行稍后继续执行的函数，核心是协作多任务，协程上下文切换只发生在用户级，多个协程可以运行在同一个线程
##### 线程和协程的区别
- 协程为协作式，只能主动释放CPU，而线程为抢占式
- 线程占用的内存资源大于协程，切换消耗大于协程
- 同一个线程中建立的多个协程无需锁  
- 协程只能运行在用户态，但线程可以运行在用户态和内核态

### 处理机调度
为什么要调度：因为进程数量要远多于CPU数量，所以争用CPU在所难免

---

##### 调度分类

调度分为以下几种
1. 高级调度（作业调度）：按照某种规则从外存上处于后备队列的作业中挑选一个，给它分配内存，IO等必要的资源，作业调度就是内存与辅存的调度
2. 中级调度：决定将外存上的那些已具备运行条件的挂起进程再重新调入内存,并修改其状态为就绪
态,挂在就绪队列上等待。中级调度实际上是存储器管理中的对换功能。
3. 低级调度：按照某种算法从就绪队列中选取一个进程,将CPU 分配给它。

##### 调度的实现
用于调度和分派CPU的组件，被称为调度程序
由三部分组成
1. 排队器：系统中所有就绪进程按照一定策略排成多个队列，以便于调度程序选择。
2. 分派器：依据调度程序所选的进程，将其就绪队列中取出，将cpu分配新进程
3. 上下文切换器：在对CPU进行切换的时候，会发生两对上下文的切换，第一对是将当前进程上下文保存到PCB中，在装入分派程序的上下文，以便于程序运行，第二对移出分派程序上下文，将新选进程的CPU现场信息分别装入CPU的各个寄存器

##### 闲逛进程
当进程切换的时候，如果系统中没有就绪进程，就会调用闲逛进程，其PID为0，其优先级最低


##### 调度算法的评价标准
1. CPU利用率
CPU利用率 = CPU有效工作时间/（CPU有效工作时间+总时间）
2. 系统吞吐量
单位时间CPU完成作业的数量
3. 周转时间
等于作业完成时间 - 作业提交时间
4. 带权周转时间
等于作业周转时间/作业实际运行时间
5. 等待时间
进程处于等待CPU的时间之和
6. 响应时间
用户提交请求到系统首次响应所使用的时间

##### CPU调度算法
1. FCFS 先来先服务 FCFS 调度算法每次从就绪队列中选择最先进入该队列的进程,将CPU 分配
给它,使之投入运行,直到运行完成或因某种原因此阻塞时才释放 CPU。
2. SJF 短作业优先算法 指对短作业有优先调度的算法
3. 高响应比优先：响应比 = （等待时间+实际运行时间）/ 实际运行时间
4. 优先级调度算法：一般来说：系统进程>用户进程 ， 交互 > 非交互 ， IO > 计算
5. 时间片轮转调度算法：主要用于分时系统，最大的特点为公平
6. 多级反馈队列调度算法（这个较为复杂，融合了前几种算法的优点）
实现思想如下
1. 设置多个就绪队列，不同队列不同优先级
2. 赋予各个队列进程的时间片大小各不相同，优先级越高，时间片就越小
3. 每级队列都采用FCFS算法
4. 按队列优先级调度：仅当第一级队列为空的时候，才会调度第二级队列的进程运行。如果又有新进程记入任何一个优先级较高的队列，那么就会发生抢占式调度

##### 多处理机调度
一般为主机进行进程调度，从机空闲的时候，从机就向主机索取一个进程

处理器亲和性：让一个进程运行在同一个CPU上
负载均衡应该设法将负载均匀分派到所有CPU中

多处理机调度方法
1. 公共就绪队列：系统中仅仅设置一个公共就绪队列，所有CPU共享
2. 私有就绪队列：每个CPU有一个私有就绪队列，然后由特定的负载均衡进程来进行负载均衡
包含推迁移和拉迁移 ：负载过高，就要推出，负载过低，就要拉入

这里介绍一个我们最常使用的负载均衡组件：nginx
其负载均衡的方法为（随机，带权分派，一致性哈希，选取负载最低的服务器）

